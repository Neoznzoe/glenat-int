import fs from 'fs';
import os from 'os';
import path from 'path';
import { spawnSync } from 'child_process';
import react from '@vitejs/plugin-react';
import type { ServerOptions as HttpsServerOptions } from 'https';
import { defineConfig } from 'vite';

const IPV4_REGEX = /^(?:\d{1,3}\.){3}\d{1,3}$/u;

const collectSubjectAltNames = (): string[] => {
  const altNames = new Set<string>(['DNS:localhost', 'IP:127.0.0.1']);

  const cliHost = process.env.HOST ?? process.env.npm_config_host ?? process.env.VITE_DEV_HOST;
  if (cliHost) {
    if (IPV4_REGEX.test(cliHost)) {
      altNames.add(`IP:${cliHost}`);
    } else {
      altNames.add(`DNS:${cliHost}`);
    }
  }

  const interfaces = os.networkInterfaces();
  for (const details of Object.values(interfaces)) {
    if (!details) continue;
    for (const detail of details) {
      if (detail.family === 'IPv4' && !detail.internal && detail.address) {
        altNames.add(`IP:${detail.address}`);
      }
    }
  }

  return [...altNames];
};

const tryGenerateSelfSignedCertificate = (): HttpsServerOptions | null => {
  const altNames = collectSubjectAltNames();

  try {
    const tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'glenat-int-https-'));
    const keyFile = path.join(tempDir, 'dev-server.key');
    const certFile = path.join(tempDir, 'dev-server.crt');

    const opensslArgs = [
      'req',
      '-x509',
      '-nodes',
      '-newkey',
      'rsa:2048',
      '-keyout',
      keyFile,
      '-out',
      certFile,
      '-days',
      '30',
      '-subj',
      '/CN=glenat-dev',
      '-addext',
      `subjectAltName=${altNames.join(',')}`,
    ];

    const result = spawnSync('openssl', opensslArgs, { encoding: 'utf8' });

    if (result.status !== 0) {
      console.warn(
        '[vite] Impossible de générer un certificat HTTPS de développement via OpenSSL. Utilisation du certificat auto-signé par défaut.',
        result.stderr?.trim() || result.error,
      );
      return null;
    }

    const httpsOptions: HttpsServerOptions = {
      key: fs.readFileSync(keyFile),
      cert: fs.readFileSync(certFile),
    };

    fs.rmSync(tempDir, { recursive: true, force: true });

    return httpsOptions;
  } catch (error) {
    console.warn(
      '[vite] Erreur inattendue lors de la création d\'un certificat HTTPS temporaire. Utilisation du certificat auto-signé par défaut.',
      error,
    );
    return null;
  }
};

const resolveHttpsConfig = (): HttpsServerOptions | false => {
  const httpsFlag = process.env.VITE_DEV_HTTPS?.trim().toLowerCase();

  if (httpsFlag && ['0', 'false', 'off', 'no'].includes(httpsFlag)) {
    return false;
  }

  const keyPath = process.env.VITE_DEV_HTTPS_KEY;
  const certPath = process.env.VITE_DEV_HTTPS_CERT;

  if ((keyPath && !certPath) || (!keyPath && certPath)) {
    console.warn(
      '[vite] Les variables VITE_DEV_HTTPS_KEY et VITE_DEV_HTTPS_CERT doivent être fournies ensemble pour activer un certificat personnalisé. Utilisation du certificat auto-signé par défaut.',
    );
  }

  if (keyPath && certPath) {
    try {
      return {
        key: fs.readFileSync(keyPath),
        cert: fs.readFileSync(certPath),
      } satisfies HttpsServerOptions;
    } catch (error) {
      console.warn(
        '[vite] Impossible de charger le certificat ou la clef privée fournis via VITE_DEV_HTTPS_KEY / VITE_DEV_HTTPS_CERT.',
        error,
      );
    }
  }

  const autoGeneratedCertificate = tryGenerateSelfSignedCertificate();
  if (autoGeneratedCertificate) {
    return autoGeneratedCertificate;
  }

  if (httpsFlag && !['1', 'true', 'on', 'yes'].includes(httpsFlag)) {
    console.warn(
      `[vite] Valeur « ${httpsFlag} » non reconnue pour VITE_DEV_HTTPS. HTTPS activé par défaut.`,
    );
  }

  return {} satisfies HttpsServerOptions;
};

export default defineConfig(() => {
  const httpsConfig = resolveHttpsConfig();
  const cliPort = process.env.npm_config_port;
  const envPort = process.env.VITE_DEV_PORT ?? process.env.PORT;
  const port = Number(cliPort ?? envPort ?? 3000);
  if (!Number.isFinite(port)) {
    console.warn(
      '[vite] Valeur de port invalide fournie via --port, VITE_DEV_PORT ou PORT. Utilisation du port 3000.',
    );
  }

  return {
    plugins: [react()],
    resolve: {
      alias: {
        '@': path.resolve(__dirname, './src'),
      },
    },
    server: {
      host: '0.0.0.0',
      port: Number.isFinite(port) ? port : 3000,
      strictPort: true,
      https: httpsConfig === false ? undefined : httpsConfig,
      proxy: {
        // Proxy de dev pour contourner CORS sur l'API Extranet
        '/extranet': {
          target: 'https://api-recette.groupe-glenat.com',
          changeOrigin: true,
          secure: false,
          rewrite: (p) => p.replace(/^\/extranet/, '/Api/v1.0/Extranet'),
        },
      },
    },
    optimizeDeps: {
      exclude: ['lucide-react'],
    },
    css: {
      transformer: 'postcss',
    },
  };
});
